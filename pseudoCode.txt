//This file serves as the pseudoCode for the c code named "R1DL.cpp";
//Created by Xiang Li (xiangli@uga.edu), 2015/11/9;

//from main():
  get input file name (containing a matrix) from the 1st argument;
  get the total number of observations of the input matrix (i.e. number of rows) from the 2nd argument, assigned to variable T;
  get the total number of variables of the input matrix (i.e. number of columns) from the 3rd argument, assigned to variable P;
  get the output dictionary (containing matrix D) file  name from the 4th argument;
  get the output loading (containing matrix z) file name from the 5th argument;
  get the output summary (i.e. log) file name from the 6th argument;
  get the total number of dictionary atoms (i.e. number of columns in matrix D) from the 7th argument, assigned to variable M;
  get the percentage of non-zero elements from the 8th argument, then times the total number of variables (P) to get the total number of non-zero elements in matrix z, assigned to variable R;
  get the epsilon (criteria of convergence), from the 9th argument, assigned to variable epsilon, then square it: epsilon=epsilon*epsilon;
  //memory-allocation steps would be omitted from the code, since it won't be needed elsewhere than in c;
  set max_iteration=P*10; //maximum iteration for each atom is 10 times the number of variables;
  provide user the feedback of the input;
  S = (load the input file);
  normalize S to zero-mean and unit-length, both column-wise;
  initialize v to zero-vector with length P;
  initialize idxs_n to zero-vector with length R //this vector will store the indices of the non-zero elements in v;
  //logging will also be omitted from the code, since it is used for diagnosis only;
  for m=0 to M //M number of dicitonary atoms;
    initialize u_old to a random vector with length T, with zero-mean and unit-length;
    while (not reaching max_iteration)
      v = u_old*S; //notice the order: vector by matrix;
      idxs_n = indices of the top R number of elements in v; //notice sorting is NOT necessary;
      u_new = S*(v selected by idxs_n); //only a portion of v will be iterated, notice the order: matrix by vector;
      normalize u_new to unit-length;
      diff = |u_old-u_new|_2;
      if (diff<epsilon)
        break; //if converging, finish the learning of current atom;
      endif
      u_old = u_new; //update u_old for the next iteration;
    end
    S = S - u_new*v; //update ("deflate") S from the last-learned atom;
    z[m] = v; D[m] = u_new; //z and D are updated after the learning of each atom (i.e. the m-th column in z and D are replaced by v and u_new. 
  next m;
  store D in file_D;
  store z in file_z;
  //All done!
