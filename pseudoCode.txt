//This file serves as the pseudoCode for the c code named "R1DL.cpp";
//Created by Xiang Li (xiangli@uga.edu), 2015/11/9; last update 2015/11/13;

//from main():
  get input file name (containing a matrix) from the 1st argument;
  get the total number of observations of the input matrix (i.e. number of rows) from the 2nd argument, assigned to variable T;
  get the total number of variables of the input matrix (i.e. number of columns) from the 3rd argument, assigned to variable P;
  get the output dictionary (containing matrix D) file  name from the 4th argument;
  get the output loading (containing matrix z) file name from the 5th argument;
  get the output summary (i.e. log) file name from the 6th argument;
  get the total number of dictionary atoms (i.e. number of columns in matrix D) from the 7th argument, assigned to variable M;
  get the percentage of non-zero elements from the 8th argument, then times the total number of variables (P) to get the total number of non-zero elements in matrix z, assigned to variable R;
  get the epsilon (criteria of convergence), from the 9th argument, assigned to variable epsilon, then square it: epsilon=epsilon*epsilon;
  //memory-allocation steps would be omitted from the code, since it won't be needed elsewhere than in c;
  set max_iteration=P*10; //maximum iteration for each atom is 10 times the number of variables;
  provide user the feedback of the input;
  S = (load the input file);
  normalize S to zero-mean and unit-length, both column-wise;
  initialize v to zero-vector with length P;
  initialize idxs_n to zero-vector with length R //this vector will store the indices of the non-zero elements in v;
  //logging will also be omitted from the code, since it is used for diagnosis only;
  for m=0 to M //M number of dicitonary atoms;
    initialize u_old to a random vector with length T, with zero-mean and unit-length;
    while (not reaching max_iteration)
      v = u_old*S; //notice the order: vector by matrix, calling op_VCTbyMTX();
      idxs_n = indices of the top R number of elements in v; //notice sorting is NOT necessary;
      u_new = S*(v selected by idxs_n); //only a portion of v will be iterated, notice the order: matrix by vector, calling op_MTXbyVCT();
      normalize u_new to unit-length;
      diff = |u_old-u_new|_2;
      if (diff<epsilon)
        break; //if converging, finish the learning of current atom;
      endif
      u_old = u_new; //update u_old for the next iteration;
    end
    S = S - u_new*v; //update ("deflate") S from the last-learned atom;
    z[m] = v; D[m] = u_new; //z and D are updated after the learning of each atom (i.e. the m-th column in z and D are replaced by v and u_new. 
  next m;
  store D in file_D;
  store z in file_z;
  //All done!

//from op_VCTbyMTX():
input: mtx_input, vct_input, I (number of rows in vct_input and mtx_input), J (number of columns in mtx_input);
output: vct_result;
  for j=0 to J
    tmp1 = 0;
    for i=0 to I
      tmp1 += vct_input[i]*mtx_input[i][j];
    next i;
    vct_result[j] = tmp1;
  next j

//from op_MTXbyVCT():
input: mtx_input, vct_input, count_row (number of rows in mtx_input), count_col (number of rows in vct_input, number of columns in mtx_input), idxs_col (indices of non-zero elements in vct_input), R (length of idxs_col);
output: vct_result;
  for idx_row=0 to count_row
    tmp1 = 0;
    for idx_r=0 to R
      idx_col = idxs_col[idx_r];
      tmp1 += vct_input[idx_col]*mtx_input[idx_row][idx_col];
    next idx_r;
    vct_result[idx_row] = tmp1;
  next idx_row
